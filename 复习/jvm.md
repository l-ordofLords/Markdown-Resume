jvm分区(基于java8)

公有和私有

公有是   堆，栈，元空间（metaspace）|方法区

线程私有   程序计数器 ，本地方法栈 虚拟机栈

![](E:\workspace\Markdown-Resume\复习\jvm内存区域.webp)

程序计数器是记录当前指令地址的

虚拟机栈   执行java方法时给这个方法创建栈帧并存入栈  里面有调用方法的一些信息

本地方法栈   用来存放本地方法的信息的

堆用来存放对象

元空间  用来存放 运行时常量池和类信息



垃圾回收

java 8    ParNew/CMS（响应优先，暂停时间短）    默认垃圾回收器就是Parallel （Parallel Scavenge/Parallel Old（吞吐量优先））

java 9     G1成为默认垃圾回收器,但是在java 7中就已经有了

java 17    G1还是默认垃圾回收器，但是部分场景用zgc也行    g1可能更多被认为是cms的替代

每代的相同名字的垃圾回收器代码不一样性能不一定一样，所以选择的时候按版本做性能测试

zgc适合机器的性能没到极限，他可以用吞吐量换取低暂停时间，换取更低的延迟和更低的响应时间

对吞吐量有要求还是选g1   吞吐量  执行业务时 单位时间内 能完成的工作量



### 选择收集器

除非应用程序具有相当严格的暂停时间要求，否则请首先运行应用程序并允许 VM 选择收集器。

如有必要，请调整堆大小以提高性能。如果性能仍未达到您的目标，请使用以下准则作为选择收集器的起点：

- 如果应用程序具有较小的数据集（最大约为 100 MB），则使用选项选择串行收集器。`-XX:+UseSerialGC`
- 如果应用程序将在单个处理器上运行，并且没有暂停时间要求，请使用选项选择串行收集器。`-XX:+UseSerialGC`
- 如果 （a） 峰值应用程序性能是第一优先级，并且 （b） 没有暂停时间要求或可以接受一秒或更长时间的暂停，则让 VM 选择收集器或选择并行收集器。`-XX:+UseParallelGC`
- 如果响应时间比总体吞吐量和垃圾回收更重要 暂停时间必须保持较短，然后选择 大多数是具有 的并发收集器。`-XX:+UseG1GC`
- 如果响应时间是高优先级，则选择具有 的全并发收集器。`-XX:UseZGC`

以上是oracle官网的java17选择垃圾回收器的建议





cms垃圾回收过程

### 回收过程：

1. **初始标记（Initial Mark）：** 在这个阶段，CMS会暂停应用线程(stw)，标记与GC Roots直接关联的对象，以建立起初始标记的快照。
2. **并发标记（Concurrent Mark）：** 在并发标记阶段，CMS通过多线程进行标记，遍历老年代中的对象，标记出存活的对象。这个阶段的目标是标记存活对象，而不会暂停应用线程。
3. **并发预清理（Concurrent Preclean）：** CMS在并发标记的同时，执行并发预清理，清理一些已经被标记为垃圾的对象。
4. **并发清理（Concurrent Sweep）：** 在并发清理阶段，CMS清理已经标记为垃圾的对象，同样在这个阶段也不会暂停应用线程。
5. **重新标记（Remark）：** 由于在并发清理阶段可能有新的对象生成，需要进行重标记，保证这些新的对象的引用关系被正确标记，此阶段需要stw。
6. **并发重置（Concurrent Reset）：** 最后，CMS执行并发重置阶段，将回收相关的数据结构恢复到初始状态，准备好下一轮的垃圾回收。

CMS收集器**优点**：并发收集、低停顿。

CMS收集器**缺点**：

第一， **垃圾碎片的问题** ，我们都知道CMS是使用的是 **标记-清除** 算法的，所以不可避免的就是会出现垃圾碎片的问题。垃圾碎片  可用空间变得不连续且大小不一，不太好进行分配对象

第二， 一般CMS的GC耗时80%都在remark阶段，remark阶段停顿时间会很长 ，在CMS的这四个主要的阶段中，最费时间的就是重新标记阶段。

第三， **concurrent mode failure** ，说出这个的时候，面试官就会觉得，小伙子，哎呦，不错哟，掌握的比较清楚，那这个是什么意思呢，其实是说：

这个异常发生在cms正在回收的时候。执行CMS GC的过程中，同时业务线程也在运行，当年轻带空间满了，执行ygc时，需要将存活的对象放入到老年代，而此时老年代空间不足，这时CMS还没有机会回收老年带产生的，或者在做Minor GC的时候，新生代救助空间放不下，需要放入老年代，而老年代也放不下而产生的。

第四， **promotion failed** ，这个问题是指，在进行Minor GC时，Survivor空间不足，对象只能放入老年代，而此时老年代也放不下造成的，多数是由于老年代有足够的空闲空间，但是由于碎片较多，新生代要转移到老年带的对象比较大,找不到一段连续区域存放这个对象导致的。

第五，CMS收集器无法处理浮动垃圾（Floating Garbage）。

第六，CMS收集器对CPU资源非常敏感。

解决：

- **垃圾碎片的问题** ：针对这个问题，这时候我们需要用到这个参数： `-XX:CMSFullGCsBeforeCompaction=n` 意思是说在上一次CMS并发GC执行过后，到底还要再执行多少次 `full GC` 才会做压缩。默认是0，也就是在默认配置下每次CMS GC顶不住了而要转入full GC的时候都会做压缩。
- **concurrent mode failure**

解决这个问题其实很简单，只需要设置两个参数即可

-XX:+UseCMSInitiatingOccupancyOnly

-XX:CMSInitiatingOccupancyFraction=60：是指设定CMS在对内存占用率达到60%的时候开始GC。

为什么设置这两个参数呢？由于在垃圾收集阶段用户线程还需要运行，那也就还需要 **预留有足够的内存空间给用户线程使用** ，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集。

当然也不能设置过高，比如90%，这时候虽然GC次数少，但是，却会导致用于用户线程空间小，效率不高，太低10%，你自己想想会怎么样，体会体会！

哈哈，万事大吉，这一点说出了，估计面试官已经爱上我了吧，赶紧把我招进去干活吧。。。

- **remark阶段停顿时间会很长的问题** ：解决这个问题巨简单，加入 `-XX:+CMSScavengeBeforeRemark` 。在执行remark操作之前先做一次 `Young GC` ，目的在于减少年轻代对老年代的无效引用，降低remark时的开销。

CMS收集器之所以能够做到并发，根本原因在于**采用基于“标记-清除”的算法并对算法过程进行了细粒度的分解**。前面篇章介绍过标记-清除算法将产生大量的内存碎片这对新生代来说是难以接受的，因此新生代的收集器并未提供CMS版本。

 "浮动垃圾"（Floating Garbage）通常用来描述一种特定的垃圾对象情况。浮动垃圾是指已经被标记为垃圾，但在垃圾回收阶段之后，由于对象引用关系的变化，这些垃圾对象重新变得可达，因此不会被回收。(所谓浮动垃圾就是正常的对象引用，但是jvm引入了读屏障（Read Barrier）来解决这里的问题，这块不理解)


full gc  按我的理解也是由策略选定的垃圾回收器  分别回收年轻代和老年代    个别比如G1会整个一起收集   别的都是年轻代和老年代分别由一个垃圾回收器负责进行组合   整体进行一个垃圾收集


标记-清除  标记-复制   标记-整理


整个堆分为  年轻代和老年代

年轻代分为eden s0 s1
对象分配先在eden   然后eden满了触发一次年轻代回收   根据选择的年轻代垃圾回收器  进行回收  一般就是标记-复制（ParNew）+标记-清除（CMS）老年代
年轻代垃圾回收  对象被标记   然后统一从eden+s0复制到s1  之前的空间都清理掉    如果对象大小超过s1 那么直接晋升老年代或者在多次活过回收后晋升老年代
老年代   就标记清除   cms的策略会产生大量垃圾碎片   年轻代用不了这算法年轻代的对象都太小了，这样会导致空间变得零碎不好分配对象   年轻代晋升老年代得时候   老年代放不下了就会触发一次full gc   这时这个晋升对象根据选择得垃圾回收器不同会有不同得策略，应该会在full gc完成后再放到老年代中  但是在full gc期间他怎么处理得这个看具体得垃圾回收器得实现
调优策略就是增大jvm的  堆内存   -Xms?m  -Xmx?m   设置堆的最小内存和最大内存    OutOfMemoryError会出现这个情况
原因是每次传感器入库的时候都临时创建了大量的对象，这部分对象入库后就会被回收掉，所以需要大量的堆空间  

这个情况一个是调整了堆的大小，还有就是建立对象池    在外部请求过来时新建立对象用来入库的时候用对象池里的对象来进行相应的处理（不能直接改参数里的对象,因为还有后续很多流程在切面里或者异步方法里，他们都需要对请求参数做处理，尤其是异步任务，对参数随便乱改会导致异步任务出问题，有较小可能产生结果上的异常）
