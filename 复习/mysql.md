mysql引擎有innodb和myisam，他们有什么区别

1. **事务支持：**
   - **InnoDB：** 提供事务支持，支持 ACID（原子性、一致性、隔离性、持久性）特性，适用于需要事务支持的应用，如银行、电商等。
   - **MyISAM：** 不提供事务支持，适用于读密集、写少的场景，如博客、新闻等。
2. **锁机制：**
   - **InnoDB：** 行级锁，对于并发访问更友好，多个事务可以同时操作不同行。
   - **MyISAM：** 表级锁，对于并发访问较差，当有一个事务在修改表时，其他事务需要等待。
3. **索引：**
   - **InnoDB：** 支持全文索引、聚簇索引，存储数据时按主键顺序组织数据，辅助索引保存主键的值。
   - **MyISAM：** 不支持全文索引，非聚簇索引，数据文件和索引文件分开存储。
4. **崩溃恢复：**
   - **InnoDB：** 支持崩溃恢复，有事务日志（redo log）来保证事务的持久性。
   - **MyISAM：** 不支持崩溃恢复，发生崩溃时可能导致表损坏。
5. **外键：**
   - **InnoDB：** 支持外键约束，保证参照完整性。
   - **MyISAM：** 不支持外键约束。
6. **性能：**
   - **InnoDB：** 适用于高并发、事务性负载，读写性能相对较好，但对存储空间的使用较高。
   - **MyISAM：** 适用于读密集、写少的场景，插入和查询性能相对较好，但对事务支持较差。
7. **表级锁和行级锁：**
   - **InnoDB：** 采用行级锁，更好地支持并发访问。
   - **MyISAM：** 采用表级锁，对于大量写操作的场景，可能会出现性能瓶颈。
8. **缓存策略：**
   - **InnoDB：** 采用缓冲池（Buffer Pool）缓存数据和索引。
   - **MyISAM：** 使用键缓存和系统缓存，对于只读操作的性能较好。

innodb的索引结构及其特点

InnoDB 存储引擎使用 B+ 树（B+ Tree）作为其索引结构，用于管理表中的数据。B+ 树是一种平衡树结构，广泛用于数据库索引的实现，具有高效的查找和范围查询性能。以下是 InnoDB 中 B+ 树的一些关键特点：

1. **B+ 树结构：**
   - B+ 树是一种平衡树结构，包含根节点、内部节点和叶子节点。
   - 所有数据都存储在叶子节点中，而内部节点仅包含用于导航的键值。
2. **有序性：**
   - B+ 树中的数据按照键值的大小顺序存储在叶子节点上。
   - 这种有序性使得 B+ 树非常适合范围查询，因为相关的数据通常在相邻的叶子节点上。
3. **非聚簇索引：**
   - InnoDB 使用 B+ 树实现非聚簇索引，即索引和实际数据分开存储。
   - 叶子节点包含实际数据的引用，而不是数据本身。
4. **聚簇索引：**
   - InnoDB 的主键索引是聚簇索引，其叶子节点包含实际的数据行。
   - 如果表没有显式定义主键，InnoDB 会选择第一个非空唯一索引作为聚簇索引，或者如果没有唯一索引，则生成一个隐藏的聚簇索引。
5. **自适应哈希索引：**不知道是干嘛的
   - InnoDB 在 B+ 树的结构上引入了自适应哈希索引的概念。
   - 自适应哈希索引可以根据查询的访问模式，将热门数据放置在 B+ 树的叶子节点中，提高查询性能。
6. **多版本并发控制（MVCC）：**
   - InnoDB 使用 B+ 树来实现多版本并发控制，以支持事务的隔离性。
   - 在 B+ 树的节点上，存储了事务的版本信息，确保不同事务之间的隔离性。
7. **页（Page）：**
   - InnoDB 将 B+ 树的节点存储在固定大小的页上，典型的大小为 16KB。
   - 页是 InnoDB 存储引擎进行磁盘和内存交互的基本单位。

mvcc

MVCC 是一种并发控制机制，用于在多个并发事务同时读写数据库时保持数据的一致性和隔离性。它是通过在每个数据行上维护多个版本的数据来实现的。当一个事务要对数据库中的数据进行修改时，MVCC 会为该事务创建一个数据快照，而不是直接修改实际的数据行。

1、读操作（SELECT）：

当一个事务执行读操作时，它会使用快照读取。快照读取是基于事务开始时数据库中的状态创建的，因此事务不会读取其他事务尚未提交的修改。具体工作情况如下：

- 对于读取操作，事务会查找符合条件的数据行，并选择符合其事务开始时间的数据版本进行读取。
- 如果某个数据行有多个版本，事务会选择不晚于其开始时间的最新版本，确保事务只读取在它开始之前已经存在的数据。
- 事务读取的是快照数据，因此其他并发事务对数据行的修改不会影响当前事务的读取操作。

2、写操作（INSERT、UPDATE、DELETE）：

当一个事务执行写操作时，它会生成一个新的数据版本，并将修改后的数据写入数据库。具体工作情况如下：

- 对于写操作，事务会为要修改的数据行创建一个新的版本，并将修改后的数据写入新版本。
- 新版本的数据会带有当前事务的版本号，以便其他事务能够正确读取相应版本的数据。
- 原始版本的数据仍然存在，供其他事务使用快照读取，这保证了其他事务不受当前事务的写操作影响。

3、事务提交和回滚：

- 当一个事务提交时，它所做的修改将成为数据库的最新版本，并且对其他事务可见。
- 当一个事务回滚时，它所做的修改将被撤销，对其他事务不可见。

4、版本的回收：

为了防止数据库中的版本无限增长，MVCC 会定期进行版本的回收。回收机制会删除已经不再需要的旧版本数据，从而释放空间。

MVCC 通过创建数据的多个版本和使用快照读取来实现并发控制。读操作使用旧版本数据的快照，写操作创建新版本，并确保原始版本仍然可用。这样，不同的事务可以在一定程度上并发执行，而不会相互干扰，从而提高了数据库的并发性能和数据一致性。

mysql事务有什么特性，叫什么

ACID   一致性（数据的完整性要保证），原子性，隔离性（多个并发事务之间，数据要保持隔离性），持久性（一个事务一旦提交，数据就是永久改变的）

事务有几种级别，分别为了解决什么问题

脏读

读取到被回滚的数据，脏数据

幻读

事务B前后两次读取同一个范围的数据，在事务B两次读取的过程中事务A新增了数据，导致事务B后一次读取到前一次查询没有看到的行。

幻读和不可重复读有些类似，但是幻读强调的是集合的增减，而不是单条数据的更新。

不可重复读

事务B读取了两次数据资源，在这两次读取的过程中事务A修改了数据，导致事务B在这两次读取出来的数据不一致。

这种在同一个事务中，前后两次读取的数据不一致的现象就是不可重复读(Nonrepeatable Read)。

事务隔离级别

- **READ-UNCOMMITTED(读取未提交)** ：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
- **READ-COMMITTED(读取已提交)** ：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。
- **REPEATABLE-READ(可重复读)** ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
- **SERIALIZABLE(可串行化)** ：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。

| 隔离级别         | 脏读 | 不可重复读 | 幻读 |
| ---------------- | ---- | ---------- | ---- |
| READ-UNCOMMITTED | √    | √          | √    |
| READ-COMMITTED   | ×    | √          | √    |
| REPEATABLE-READ  | ×    | ×          | √    |
| SERIALIZABLE     | ×    | ×          | ×    |

虽然`REPEATABLE READ`隔离级别对单行记录的读取是可重复的，但对于范围查询，它无法保证在事务的整个生命周期内看到的数据是一致的，可能会出现幻读。

雪花算法生成的id是有序的，uuid是无序的

uuid不适合用作数据主键，雪花算法生成的id是可以的

#### 嵌入到业务代码里，也就是分布在业务服务器中

这种方案的好处是业务代码在使用的时候不需要跨网络调用，性能上会好一些，但是就需要更多的机器 ID 位数来支持更多的业务[服务器](https://cloud.tencent.com/act/pro/promotion-cvm?from_column=20065&from=20065)。另外，由于业务服务器的数量很多，我们很难保证机器 `ID` 的唯一性，所以就需要引入 `ZooKeeper` 等分布式一致性组件来保证每次机器重启时都能获得唯一的机器 `ID`。

#### 作为独立的发号器服务部署

业务在使用发号器的时候就需要多一次的网络调用，但是内网的调用对于性能的损耗有限，却可以减少机器 `ID` 的位数，如果发号器以主备方式部署，同时运行的只有一个发号器，那么机器 `ID` 可以省略，这样可以留更多的位数给最后的自增信息位。即使需要机器 `ID`，因为发号器部署实例数有限，那么就可以把机器 `ID` 写在发号器的配置文件里，这样即可以保证机器 `ID` 唯一性，也无需引入第三方组件了。**微博和美图都是使用独立服务的方式来部署发号器的，性能上单实例单 CPU 可以达到两万每秒。**

sql优化

回表

我们知道在 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次，这样就会比较慢。而覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！

## 索引下推

**索引下推（Index Condition Pushdown）** 是 **MySQL 5.6** 版本中提供的一项索引优化功能，可以在非聚簇索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数。

把sql的查询条件提前提到对非聚簇索引的查询里。（联合查询放最后的查询条件有没有用就不知道了，需要再实验）

用 `EXPLAIN` 命令来分析 SQL 的 **执行计划**



在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。

主索引频繁分裂是指数据库表的主键索引（或称聚簇索引）在数据插入或更新时，由于数据的增长或变更，导致索引页的分裂现象发生频繁。这可能会对数据库性能产生一些影响。

在数据库中，主索引通常是按照主键值的顺序排列的，而聚簇索引就是按照表的主键值来组织表中的数据的索引。当表的主键值有序增长时，数据的插入或更新可能导致主索引页满或达到某个阈值，此时数据库系统会进行索引页的分裂。

索引页的分裂可以发生在以下情况：

1. **插入新记录：** 当插入一条新记录，而插入的位置超出了当前主索引页的容量时，数据库系统可能会将该页分裂为两个新的页，以容纳新的数据。
2. **主键值更新：** 如果更新某条记录的主键值，而新的主键值导致记录需要移动到另一个位置，那么也可能触发主索引页的分裂。

频繁的主索引分裂可能导致以下问题：

- **性能影响：** 索引的分裂过程可能涉及到数据的移动和重新组织，这可能会引起一定的性能开销，尤其是在数据量庞大的情况下。
- **空间碎片：** 分裂后的索引页可能留下一些空闲的空间，导致索引空间的碎片化，影响存储效率。

为了减轻主索引频繁分裂的影响，可以考虑以下措施：

1. **合理设置主键：** 尽量避免使用会导致主键频繁增长的字段作为主键。
2. **定期维护索引：** 可以定期进行索引的优化和重建，以减少索引空间的碎片化。
3. **考虑使用非聚簇索引：** 如果主索引频繁分裂影响性能，可以考虑将主索引改为非聚簇索引，或者选择合适的存储引擎，如InnoDB，以减轻这种影响。

优化索引，优化sql,调整代码，异步代码，加缓存，不涉及主业务的操作各种日志包括监控代码异步给mq让监控服务异步消费消息去

报警的异步处理，拉出现在所有的报警，然后先更新之前所有的报警（在数据日期之前的）为已完成

然后再更新现有的报警